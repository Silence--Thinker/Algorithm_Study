# 翻转

## 问题

这里有100张写着数字的1~100的牌，并按顺序排列着。最开始所有牌都是背面朝上放置。某人从第2张牌开始，隔1张牌翻牌。
然后第2、4、6、8……、100张牌就会变成正面朝上。

接下来第2个人从第3张牌开始，隔2张牌翻牌（原本背面朝上的，翻转成正面朝上；原来正面朝上的，翻转成背面朝上）。
在接下来，又有一个人从第4张牌开始，每隔3张牌翻牌。

像这样，从第n张牌开始，每隔n-1张牌翻牌，直到没有可翻动的牌为止。

求当所有牌不在变动时，所有背面朝上的牌的数字？

## 思路

根据问题的描述，按顺序对牌进行翻转处理。用数组保存牌的状态，如果牌正面朝上，则设置值为true，反之为false。

### 代码03.01

    def reversal_01 ()
        n = 100
        cards = Array.new(n, false)

        # 从2到n翻牌
        (2..n).each {|i|
            j = i - 1
            while j < cards.size do
                cards[j] = !cards[j]
                j += i
            end
        }
        n.times{|i|
            puts i + 1 if !cards[i]
        }
    end

`Point`: 代码03.01使用数组来实现的，但是从左到右按顺序处理也就意味着“已经翻转过的部分不再翻转”。如果针对这一点进行优化。可以得到：

### 代码03.02

    def reversal ()
        n = 100
        (1..n).each {|i|
            flag = false
            (2..n).each{|j|
                if i % j == 0       
                    flag = !flag
                end
            }
            puts "#{i}" if flag==false
        }
    end

执行代码得出的答案是：1、4、9、16、25、36、49、64、81、100。从答案可以看到，结果都是“平方数”。

### 进一步思考🤔

如果翻盘操作进行了奇数次，则最后是正面朝上；如果进行了偶数次，则最后是背面朝上。也就是说，这个问题等价于 “寻找被翻转次数为偶数的牌”。

而翻转操作的时机是“翻牌间隔数字是这个数的约数时”，因此也就相当于寻找拥有偶数个“1以外的约数”的数字。

举个列子，12的约数是：1、2、3、4、6、12这6个数。也就是偶数个。把约数从小到大排序，并将两端的数按照顺序相乘就可以得到原数。

    1✖️12, 2✖️6, 3✖️4,

不过16的约数是：1、2、4、8、16这5个。也就是奇数个。我们把余数从小到大排序，并将两端的数按顺序相乘后，会剩下正中间的数字4.

    1✖️16, 2✖️8,
    ※ 剩下的数字乘以自身可以得到原数（4✖️4=16）

## 结论

也就是说，只有当牌面数字式平方数的时候约数才是奇数个，也就是除1以外的约数是偶数个。了解到了这个规律后，即使不编程，也能知道答案。
